## Анализ проблемы

**Причина:** При русской раскладке клавиатуры комбинация Ctrl+V генерирует keysym `Control-Cyrillic_em` вместо стандартного `Control-v`, и текущие привязки не работают надежно.

**Проблема:** Пользователь не может вставить IP/Port из буфера обмена при русской раскладке, приходится переключаться на английскую.

## Решение

Использовать привязки к **физическим кодам клавиш** (`keycode`), которые одинаковы в любой раскладке:

### Изменения в коде:

1. **В методе `create_input`**:
   - Заменить текущие привязки на основе keysym на привязки на основе keycode
   - Добавить обработку Ctrl+C (keycode 67) и Ctrl+V (keycode 86)

2. **Код для замены:**
   ```python
   # Add keyboard shortcuts using physical keycodes (works in any layout)
   try:
       # Ctrl+C (copy) - physical key code 67
       entry.bind('<Control-KeyPress-67>', lambda e: entry.event_generate('<<Copy>>'))
       # Ctrl+V (paste) - physical key code 86
       entry.bind('<Control-KeyPress-86>', lambda e: entry.event_generate('<<Paste>>'))
   except:
       pass
   ```

### Почему это работает:
- **Keycode** - физический код клавиши, одинаковый в любой раскладке
- **86** - код клавиши 'V' на стандартной клавиатуре
- **67** - код клавиши 'C'
- `event_generate('<<Paste>>')` - запускает стандартное поведение вставки

### Преимущества:
1. Работает в любой раскладке (русская, английская, украинская и т.д.)
2. Нет необходимости в transliterate для цифровых значений
3. Простая и надежная реализация
4. Сохраняет стандартное поведение вставки

### Отладка:
- Убраны ненадежные привязки на Cyrillic_em
- Добавлены универсальные привязки по keycode
- Сохранено контекстное меню для вставки

Это решение позволит пользователям вставлять IP/Port из буфера обмена при любой раскладке клавиатуры, улучшив пользовательский опыт.